
가상화 기술
==============
가상환경
--------





가상화 구조


펌웨어?

일반적으로 ROM에 저장된 하드웨어를 제어하는 마이크로 프로그램을 의미한다. 프로그램이라는 관점에서는 소프트웨어와 하드웨어와 밀접한 관계를 가지고 있다는 점에서 일반 응용소프트웨어와 구분되어 펌웨어는 소프트웨어와 하드웨어의 특성을 모두 가지고 있다고 할 수 있다.

예를 들어, 어떤 기능을 발휘하는 하드웨어를 만든다고 할 때, 그것을 제어하는 모든 회로를 하드웨어로만 만들면, 그 구조도 대단히 복잡해지고 심지어는 논리적인 표현을 하기가 어려운 부분도 발생한다.

이런 경우 상당부분을 소프트웨어로 대체하되 그 소프트웨어가 저장된 기억장치를 하드웨어의 제어 회로중의 중심부분으로 구성하면, 매우 간단하면서도 적은 비용으로 문제를 해결할 수 있게된다. 이렇게 만든 하드웨어적인 소프트웨어를 펌웨어라 한다.

소프트웨어의 기능을 펌웨어로 변경할 수 있으면 속도가 현저하게 증대되어 고속 처리가 필요한 프로그램은 펌웨어로 만들어 사용하기도 한다.
또한 하드웨어의 기능을 펌웨어로 변경하면 속도는 느려지지만, 그 기능을 위한 논리 회로를 설계하여 사용하는 것 보다 저렴하고, 편리하게 구현하여 사용할 수 있는 장점을 가진다.

미들웨어?

하드웨어와 소프트웨어의 중간 제품. 마이크로 코드 등을 말한다. 운영체제와 응용프로그램 중간에 위치하는 소프트웨어. 주로 통신이나 트랜잭션 관리를 실행하며, 대표적인 미들웨어로는 CORBA와 DCOM이 있다. 이 소프트웨어는 클라이언트 프로그램과 데이터베이스 사이에서 통신을 운용하는데 쓰인다. 예를 들어, 데이터베이스에 연결된 웹 서버기

Docker의 기본 기능
==============
Docker의 세가지 기능
<ol>
  <ul> 1. Docker 이미지 생성 </ul>
  <ul> 2. Docker 컨테이너 동작 </ul>
  <ul> 3. Docker 이미지 공개 및 공유 </ul>
</ol>


### Docker image 생성
Docker는 애플리케이션 실행에 필요한 프로그램, 라이브러리, 미들웨어와 OS, 네트워크 설정등을 하나로 모아
'Docker image'를 생성한다. Docker image는 실행환경에서 동작하는 컨테이너의 기반이 된다.

Docker image란 애플리케이션 실행에 필요한 파일이 담긴 디렉터리다. Docker 커맨드를 사용하면 이미지를 tar파일로 만들 수 있다.
Docker이미지는 Docker 커맨드를 사용하여 수동으로 만들 수 있으며 Dockerfile 프로그램을 통해 자동으로 생성할 수도 있다.

Docker 이미지를 중첩하여 사용할 수도 있다.
예를 들어,
OS용 이미지에 웹 애플리케이션 용 이미지를 겹쳐 새로운 이미지를 생성할 수 있다.
Docker에서는 구성 변경이 일어난 부분을 따로 관리한다.

### Docker container 동작
Docker는 Linux상에서 컨테이너 단위로 서버를 구동시킨다. 이 컨테이너의 기반이 되는 것이 Docker이미지이다.
Docker 이미지를 통해 Docker가 설치됐다면 어디에서든 컨테이너를 구동시킬 수 있다.
또한 Docker 이미지를 통해 여러 컨테이너를 구동시킬 수도 있다. 컨테이너의 기동, 정지, 파기는 Docker 커맨드로 이루어진다.
다른 가상화 기술로 서버를 사용할 때에는 OS부터 구동시켜야 하므로 시간이 소요되지만 Docker는 이미 동작하고 있는 OS상에서 프로세스를
실행시키는 것과 거의 비슷한 속도로 빠르게 기동한다.

Docker는 하나의 Linux kernel을 여러 container가 공유한다. container 내에서 동작하는 프로세스를 하나의 그룹으로 관리하고
그룹별로 각각 다른 파일 시스템과 호스트명, 네트워크 등이 할당된다.
서로 다른 그룹인 경우, 프로세스와 파일에 액세스할 수 없다.
이러한 구조로 컨테이너를 독립된 공간으로 관리하며 이를 실현하기 위하여 Linux 커널 기능(namespace, cgroup 등)이
사용되고 있다.

### Docker 이미지 공개 및 공유
Docker 이미지는 Docker 레지스트리에서 통합적으로 관리할 수 있다.
예를 들어 공식 Docker 레지스트리인 Docker Hub에서는 Ubuntu와 CentOS 등 Linux 배포판의 기본 기능을 제공하는 베이스 이미지가
배포되어 있다. 이 베이스 이미지에 미들웨어와 라이브러리, 애플리케이션 등을 포함한 이미지를 중첩하여 독자적인 Docker 이미지를 만들고 있다.
또한 공식 이미지 이외에도 개인이 개발한 이미지를 Docker Hub에서 자유롭게 공개하여 공유할 수 있다.

또한 Docker Hub는 GitHub와 Bitbucket과 연계할 수도 있다. 예를 들어 GitHub 위에서 Dockerfile을 관리하고 Docker이미지를
자동으로 관리하고 Docker이미지를 자동으로 생성하여 Docker Hub에 공개할 수 있다. 이처럼 자동으로 생성하는 기능을 Automated Build라 한다.

### Docker 컴포넌트
Docker는 코어 기능을 제공하는 'Docker Engine'을 중심으로, 이미지를 생성, 공개, 컨테이너 실행하기 위한 여러 가지 컴포넌트를 제공한다.
현재 공개 및 배포된 주요 컴포넌트는 다음과 같다.



<strong> Docker에서 애플리케이션 실행 환경을 구동하기 위해 이러한 컴포넌트를 필요에 맞게 조합하여 사용한다.

> Docker Toolbox
> Docker를 클라이언트 OS에서 사용하기 위하여 




Docker의 동작 구조
==============
Docker는 Linux상에서 동작하는 가상화 기술을 기반으로 한다.(그러므로 Linux 커널 기능에 대한 이해가 필요하다.)

### 컨테이너를 구분하는 구조 (name space)
Docker는 컨테이너라는 독립된 환경을 만들고 이를 나누어 애플리케이션 실행 환경을 만든다.
이처럼 컨테이너를 나눌 때 Linux 커널의 namespace 기능을 사용한다.
> namespace는 한데 합쳐진 데이터에 이름을 붙여 충돌 가능성을 낮추고 쉽게 참조할 수 있도록 하는 기능을 말한다.
> 이름이 어떤 namespace에 속하느냐에 따라 달라지며 같은 이름이더라도 서로 다른 namespace라면 다른 존재로 인식된다.


Linux 커널의 namespace기능은 Linux오브젝트에 이름 붙이는 것을 통하여 다음 6가지 독립된 환경을 구축할 수 있다.
<br>
#### PID namespace
PID는 Linux에서 각 프로세스에 할당된 고유한 ID를 의미한다. PID namespace는 PID와 프로세스를 분리한다.
namespace가 서로 다른 프로세스는 서로 액세스할 수 없다.

#### Network namespace
네트워크 디바이스, IP Address, 포트 번호, 라우팅 테이블, 필터링 테이블 등 네트워크 리소스를 namespace별로 할당할 수 있음.
이 기능을 통해 호스트OS위에서 사용 중인 포트가 있어도 컨테이너 안에서 같은 번호의 포트를 사용할 수 있다.

#### UID namespace
UID namespace는 UID (user ID), GID (group ID)를 namespace별로 독립하여 가질 수 있음.
namespace안에서 호스트OS상의 UID 및 GID와 서로 연결되어 namespace 안과 밖에서 서로 다른 UID 및 GID를 가질 수 있다.

예를 들어, namespace 내에서 UID 혹은 GID가 0인 root 사용자를 호스트OS상에서는 일반 사용자로 인식할 수 있다.
이러한 기능을 통해 namespace의 관리자 계정이 호스트OS에서는 관리 권한을 가질 수 없게 할 수 있으므로 보다 보안을 강화할 수 있다.


#### MOUNT namespace
Linux에서 파일 시스템을 사용하기 위해서는 마운트가 필요하다.
마운트란 컴퓨터에 접속한 기기와 기억장치를 OS에 인식시키는 것을 의미한다.
MOUNT namespace는 마운트를 조작하여 namespace내에 파일 시스템 트리를 만든다.
다른 namespace기능과 마찬가지로 namespace내의 마운트는 호스트OS와 다른 namespace에서
액세스 할 수 없도록 되어있다.

#### UTS namespace
namespace별로 호스트명과 도메인명을 독자적으로 가질 수 있다.

#### IPC namespace
프로세스 간의 통신(IPC) 오브젝트를 namespace별로 가질 수 있다.
IPC는 공유 메모리와 세마포어 및 메시지 큐의 System V 프로세스 간의 통신 오브젝트임.
세마포어란, 프로세스에 필요한 자원 관리에 이용되는 Beta 제어방식이며,
메시지 큐는 여러 프로세스 사이에서 비동기 통신이 이루어질 때 사용하는 큐잉 방식이다.

<strong> Docker는 이러한 namespace방식을 사용하여 호스트상에서 컨테이너를 가상으로 구분한다.

### 리소스 관리 구조 (cgroup)
Docker는 여러 컨테이너에서 물리 머신의 리소스를 공유하여 사용한다.
이때 Linux의 커널 기능인 cgroup을 이용하여 리소스 할당 등의 관리를 수행한다.

Linux에서는 프로그램을 '프로세스'로 실행하며 이는 하나 이상의 thread단위로 동작한다.
cgroup은 프로세스 및 thread를 그룹화하여 이를 관리하는 기능이다.
이를 통해 호스트OS의 CPU, 메모리와 같은 리소스를 그룹별로 제한할 수 있다.
cgroup으로 컨테이너 내의 프로세스 리소스를 관리함으로써, 한 컨테이너가 같은 호스트OS상에서 동작하는
다른 컨테이너에 영향을 주는 일을 막을 수 있다.

cgroup을 통해 주요 서브시스템을 관리할 수 있다.
cgroup의 계층 구조상에서 하위 cgroup은 상위 cgroup의 제한 설정이 그대로 적용된다.
예를 들어 하위 cgroup의 설정이 상위 cgroup에 설정된 제한을 넘더라도 상위 cgroup의 제한에 맞도록 적용된다.


## 네트워크 구성
가상 bridge 및 가상 NIC

## Docker network 구성
![1](https://i.imgur.com/2jNsoTl.png)
Docker 컨테이너는 서버의 물리 NIC와 별도로 각 컨테이너마다 가상 NIC가 할당되어 있다.

이러한 가상 NIC는 docker0이라는 가상 bridge에 접속하여 컨테이너끼리 통신한다.

docker0은 Docker데몬을 기동한 후에 생성되며 172.17.42.1 주소가 할당된다.
> 기본적으로 docker를 설치하자마자 받는 네트워크 주소범위는 172.17.42.1/16으로 되어있음. 직접 서브넷팅하여, 주소범위를 바꿀 수 있음.

> service docker status
> service

Docker에서 컨테이너를 구동하면 컨테이너에 172.17.0.0/16 subnet mask를 가진 private IP Address가 eth0에 자동으로 할당된다.
eth0은 호스트OS에 생성된 가상 NIC(vethxxx)가 페어로 할당된다.
veth는 OSI 7계층 Layer2의 가상 네트워크 인터페이스로서 페어된 NIC끼리 터널링 통신을 수행한다.

Docker 컨테이너 간의 통신
동일한 호스트 상의 Docker 컨테이너는 구동 시 private Address가 자동으로 할당되므로 컨테이너끼리 통신하기 위하여 '링크 기능'을 사용한다. 이를 사용하면 한 호스트 상에 여러 컨테이너가 동작하는 경우, 컨테이너의 alias명을 통해 서로 다른 컨테이너에 접속할 수 있다. 컨테이너를 구동할 때, 통신하려는 컨테이너 이름을 지정하여 링크하면 해당 정보가 /etc/host에 환경변수로 저장되어 직접 통신할 수 있다.

Docker는 일반적으로 1컨테이너 1프로세스로 운영된다.
웹 서버용 컨테이너와 DB서버용 컨테이너에서 데이터를 연계하거나 각종 서버용 컨테이너의 로그파일을 로그용 컨테이너에 출력하는 방식으로 사용할 수 있다.

단, 링크 기능을 사용한 통신은 동일 호스트, 즉 가상 bridge docker0에 접속한 컨테이너까지만 가능하다. 멀티 호스트 환경에서는 링크 기능을 이용한 통신이 불가능하므로 주의해야함. 또한 보안 요구사항에 따라 컨테이너 간 통신을 차단하도록 설정할 수 있다.

Docker 컨테이너와 외부 네트워크 통신
Docker 컨테이너가 외부 네트워크와 통신할 때에는 가상 bridge docker0과 호스트OS의 물리NIC에서 패킷을 전송해야 한다. 이때, DOcker에서는 NAPT기능을 사용하여 접속한다.

> NAPT(Network Address Port Translation)란
> 하나의 IP Address를 여러 컴퓨터에서 공유하는 기술로서
> IP Address와 포트 번호를 변환하는 기능이다.
> private IP Address와 global IP Address를 상호변환하는 기술.
> TCP 및 UDP 포트 번호까지 동적으로 변환하기 때문에 여러 머신에서 한 global IP Address로 접속할 수 있다.
> Doker에서는 Linux의 iptables를 NAPT에 사용하고 있음.

이 기능은 컨테이너를 구동할 때, 내부에서 사용하고 있는 포트를 가상 bridge docker0에 개방할 때 사용된다.
예를 들어, 컨테이너 구동시, 컨테이너 내의 웹 서버(http 데몬)가 사용하는 80번 포트를 호스트OS의 8080번 포트로 전송하도록 설정하였을 때, 외부 네트워크에서 호스트OS의 8080번 포트에 액세스하면 컨테이너 내의 80번 포트로 연결되는 구조이다.


## Docker 이미지의 데이터 관리 구조

Docker에서는 Copy on Write 방식으로 컨테이너 이미지의 변경을 관리한다.

> Copy on Write 방식?
> 데이터를 바로 복사하지 않고 원본을 그대로 참조하여 원본 또는 복사본 데이터 중 하나가 변경될 때 빈 공간을 확보하여
> 데이터를 복사하는 구조

Docker 이미지는 OS와 미들웨어의 디렉터리를 포함하기 때문에 용량이 매우 크다. 때문에 용량이 한정된 물리 스토리지 영역을
효율적으로 사용하기 위하여 Copy on Write로 이미지의 변경을 관리한다.

Docker이미지를 관리하는 스토리지 디바이스는

Btrfs
Oracle에서 2007년에 발표한 Linux용 Copy on Write 파일 시스템이다. Docker는 Btrfs의 subvolume 기능과
snapshot기능을 사용하여 컨테이너 이미지의 변경을 파일 시스템 층에서 관리한다.

AUFS
서로다른 파일 시스템의 파일과 디렉터리를 중첩하여 하나의 파일트리를 구성할 수 있는 파일 시스템이다.
단, AUFS는 현재 Linux 커널 표준이 아니기 때문에 향후 어떻게 사용될지 알 수 없다.
Mac OS X와 Windows에서 동작하는 Boot2Docker에서는 AUFS가 사용되고 있다.

Device Mapper
Linux 커널 2.6에 탑재된 Linux 블록 디바이스 드라이버와 이를 지원하는 라이브러리.
Device Mapper는 파일 시스템의 블록I/O와 디바이스 매핑을 관리한다.
Docker는 Device Mapper의 thin-provisioning 기능과 스냅샷(snapshot) 기능을 활용하고 있다.
개별 파일 시스템에 의존하지 않으므로 다양한 환경에서 사용할 수 있음.
CentOS와 Fedora등 Red Hat계 OS와 Ubuntu등에서 Docker를 사용할 때 Device Mapper가 쓰인다.

overlay
Union filesystem의 하나로 파일 시스템에 또 다른 파일 시스템을 합치는 구조.
Linux 커널 3.18에 탑재된 기능으로, 읽기 전용 파일 시스템에 출력이 가능한 파일 시스템을 중첩하여
읽기 전용 파일 시스템의 디렉터리와 파일을 출력할 수 있게 만든다.
Docker는 1.4.0에서 overlayfs에 대응한다. 컨테이너 동작에 특화된 Linux 배포판인 CoreOS가 overlayfs를
채용하고 있다.
